\hypertarget{classft_1_1_parser}{}\section{Parser Class Reference}
\label{classft_1_1_parser}\index{Parser@{Parser}}


{\ttfamily \#include $<$Parser.\+hpp$>$}



Collaboration diagram for Parser\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=236pt]{classft_1_1_parser__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classft_1_1_parser_a6bfb42ee628e026bebda9adb7ae8b895}{Parser} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_http_block}{Http\+Block} $>$ \hyperlink{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248}{parse} (std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$ \&tokens)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08}{modify\+Identifier\+Token} (std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$ \&tokens)
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{check\+Valid\+Directive} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98}{check\+Valid\+Parameter\+Number} (std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \&valid\+Directive)
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_token}{Token} $>$ \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expect\+Token} (enum \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921}{Token\+Type} type, const std\+::string \&name=std\+::string())
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b}{expect\+Http\+Context} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd}{expect\+Server\+Context} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73}{expect\+Location\+Context} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_a292bf0ed87b8e81b59cefb72c70152bd}{expect\+Simple\+Directive} (enum \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75d}{Directive\+Kind} kind)
\item 
std\+::pair$<$ bool, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ $>$ \hyperlink{classft_1_1_parser_a2d0fd9222eca5d8ea7e8fbb79f0a30be}{parse\+Context\+Body} (enum \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75d}{Directive\+Kind} kind)
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_http_block}{Http\+Block} $>$ \hyperlink{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d}{parse\+Http\+Context} (std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ valid\+Directive)
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_server_block}{Server\+Block} $>$ \hyperlink{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230}{parse\+Server\+Context} (\hyperlink{classft_1_1_http_block}{Http\+Block} \&http\+Context, std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ valid\+Directive)
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_location_block}{Location\+Block} $>$ \hyperlink{classft_1_1_parser_a87f0f31d2bc2e6357d522e70256878ca}{parse\+Location\+Context} (\hyperlink{classft_1_1_server_block}{Server\+Block} \&server\+Context)
\item 
bool \hyperlink{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}{set\+Base\+Directive\+Parameter} (\hyperlink{classft_1_1_base_directives}{Base\+Directives} \&context, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$\+::iterator \&current\+Directive)
\item 
bool \hyperlink{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf}{set\+Http\+Directive\+Parameter} (\hyperlink{classft_1_1_http_block}{Http\+Block} \&context, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ directive\+List)
\item 
bool \hyperlink{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f}{set\+Server\+Directive\+Parameter} (\hyperlink{classft_1_1_server_block}{Server\+Block} \&context, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ directive\+List)
\item 
bool \hyperlink{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c}{set\+Location\+Directive\+Parameter} (\hyperlink{classft_1_1_location_block}{Location\+Block} \&context, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ directive\+List)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$\+::iterator \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{current\+Token\+\_\+}
\item 
std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$\+::iterator \hyperlink{classft_1_1_parser_a85bbb595991c68a1ec2751fabcb8eae5}{start\+Token\+\_\+}
\item 
std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$\+::iterator \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{end\+Token\+\_\+}
\item 
std\+::map$<$ std\+::string, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 14 of file Parser.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classft_1_1_parser_a6bfb42ee628e026bebda9adb7ae8b895}\label{classft_1_1_parser_a6bfb42ee628e026bebda9adb7ae8b895}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!Parser@{Parser}}
\index{Parser@{Parser}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{Parser()}{Parser()}}
{\footnotesize\ttfamily \hyperlink{classft_1_1_parser}{Parser} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 5 of file Parser.\+cpp.


\begin{DoxyCode}
6     \{
7         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"http"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP}, \textcolor{stringliteral}{"http"});
8         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"server"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}, \textcolor{stringliteral}{"server"});
9         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"location"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION}, \textcolor{stringliteral}{"location"});
10         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"client\_max\_body\_size"}] = Directive(
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da026a7fa9f276b046081164564a62a6d6}{CLIENT\_MAX\_BODY\_SIZE}, \textcolor{stringliteral}{"client\_max\_body\_size"});
11         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"keepalive\_timeout"}] = Directive(
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75daaefe179bd74ff161beb62eb565186d89}{KEEPALIVE\_TIMEOUT}, \textcolor{stringliteral}{"keepalive\_timeout"});
12         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"index"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da5f0c05bad71a7b0dd266aae7ce4b3579}{INDEX}, \textcolor{stringliteral}{"index"});
13         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"autoindex"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8ce880864e00bec4865ba027e32a466c}{AUTOINDEX}, \textcolor{stringliteral}{"autoindex"});
14         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"root"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75dad41208b99e347d1726824779b11ea11b}{ROOT}, \textcolor{stringliteral}{"root"});
15         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"error\_page"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da69c9592b502329f43c77ad043a13e6d9}{ERROR\_PAGE}, \textcolor{stringliteral}{"error\_page"});
16         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"listen"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da331ec9878c0ed22e62de969d4b96b5bb}{LISTEN}, \textcolor{stringliteral}{"listen"});
17         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"server\_name"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8e7adb687472b53e3ed632cbcb949d88}{SERVER\_NAME}, \textcolor{stringliteral}{"server\_name"});
18         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"return"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da520e09ffec033636dba711f3441cc600}{RETURN}, \textcolor{stringliteral}{"return"});
19         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"cgi"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da7b2e2f10add9bba874f82f39725423c5}{CGI}, \textcolor{stringliteral}{"cgi"});
20         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"cgi\_path"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da874adc6c563690bc7a39ac6a0060e38a}{CGI\_PATH}, \textcolor{stringliteral}{"cgi\_path"});
21         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"limit\_except"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da25b0e84438d71cc28e97f17a01cfde7a}{LIMIT\_EXCEPT}, \textcolor{stringliteral}{"limit\_except"});
22     \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}\label{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!check\+Valid\+Directive@{check\+Valid\+Directive}}
\index{check\+Valid\+Directive@{check\+Valid\+Directive}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{check\+Valid\+Directive()}{checkValidDirective()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ check\+Valid\+Directive (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 83 of file Parser.\+cpp.


\begin{DoxyCode}
84     \{
85         std::pair<bool, Token> possibleDirectiveToken = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921ae3852cb010d5e422026faf83b3c16f0e}{DIRECTIVE});
86         std::map<std::string, Directive>::iterator foundDirective;
87 
88         \textcolor{keywordflow}{if} (!possibleDirectiveToken.first)
89             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}.begin()->second)); 
90         foundDirective = \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}.find(possibleDirectiveToken.second.text);
91         \textcolor{keywordflow}{if} (foundDirective == \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}.end())
92         \{
93             --\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
94             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}.begin()->second)); 
95         \}
96         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, foundDirective->second)); 
97     \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=293pt]{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98}\label{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!check\+Valid\+Parameter\+Number@{check\+Valid\+Parameter\+Number}}
\index{check\+Valid\+Parameter\+Number@{check\+Valid\+Parameter\+Number}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{check\+Valid\+Parameter\+Number()}{checkValidParameterNumber()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ check\+Valid\+Parameter\+Number (\begin{DoxyParamCaption}\item[{std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \&}]{valid\+Directive }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 612 of file Parser.\+cpp.


\begin{DoxyCode}
613     \{
614         std::vector<Token>::iterator startToken = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
615         std::pair<bool, Token> possibleParameter = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER});
616 
617         \textcolor{keywordflow}{if} (possibleParameter.first == \textcolor{keyword}{true})
618         \{
619             \textcolor{keywordflow}{if} ((validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8e7adb687472b53e3ed632cbcb949d88}{SERVER\_NAME}) ||
620                     (validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da25b0e84438d71cc28e97f17a01cfde7a}{LIMIT\_EXCEPT}) ||
621                     (validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da5f0c05bad71a7b0dd266aae7ce4b3579}{INDEX}) ||
622                     (validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da520e09ffec033636dba711f3441cc600}{RETURN}))
623             \{
624                 \textcolor{keywordflow}{while} (possibleParameter.first == \textcolor{keyword}{true})
625                 \{
626                     validDirective.second.parameters.push\_back(possibleParameter.second.text);
627                     possibleParameter = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER});
628                 \}
629             \}
630             \textcolor{keywordflow}{else}
631                 validDirective.second.parameters.push\_back(possibleParameter.second.text);
632         \}
633         \textcolor{keywordflow}{else}
634         \{
635             std::cout << \textcolor{stringliteral}{"Error: Simple directive should at least one parameter\(\backslash\)n"};
636             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
637             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, validDirective.second));
638         \}
639         possibleParameter = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER});
640         \textcolor{keywordflow}{if} (possibleParameter.first == \textcolor{keyword}{true})
641         \{
642             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
643             std::cout << \textcolor{stringliteral}{"Error: There can't be more parameters with directive "} << validDirective.second.
      name << \textcolor{stringliteral}{", "};
644             std::cout << \textcolor{stringliteral}{"additional parameter is "} << possibleParameter.second.text<< \textcolor{stringliteral}{".\(\backslash\)n"};
645             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, validDirective.second));
646         \}
647         std::pair<bool, Token> possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{";"});
648         \textcolor{keywordflow}{if} (possibleOperator.first == \textcolor{keyword}{false})
649         \{
650             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
651             std::cout << \textcolor{stringliteral}{"Error: Simple directive should be terminated by ';' \(\backslash\)n"};
652             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, validDirective.second));
653         \}
654         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, validDirective.second));
655     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=333pt]{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b}\label{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Http\+Context@{expect\+Http\+Context}}
\index{expect\+Http\+Context@{expect\+Http\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Http\+Context()}{expectHttpContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ expect\+Http\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 294 of file Parser.\+cpp.


\begin{DoxyCode}
295     \{
296         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
297         std::pair<bool, Directive> possibleValidDirective = \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{checkValidDirective}();
298 
299         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} == \hyperlink{classft_1_1_parser_a85bbb595991c68a1ec2751fabcb8eae5}{startToken\_} && possibleValidDirective.first == \textcolor{keyword}{false}) 
300         \{
301             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
302             \textcolor{comment}{//std::cout << "(start token) = " << startToken\_->text << "\(\backslash\)n";}
303             \textcolor{comment}{//std::cout << "(current token, line) = " << currentToken\_->text << ", " <<
       currentToken\_->lineNumber << "\(\backslash\)n";}
304             std::cout << \textcolor{stringliteral}{"Error: first directive should be http block.\(\backslash\)n"};
305             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
306         \}
307         \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{false}) 
308         \{
309             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
310             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
311         \}
312         \textcolor{keywordflow}{if} (possibleValidDirective.second.directive != \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP})
313         \{
314             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
315             std::cout << \textcolor{stringliteral}{"Error: It should start with http context but the directive is "} << 
      possibleValidDirective.second.name << \textcolor{stringliteral}{"\(\backslash\)n"};
316             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
317         \}
318         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\{"}).first == \textcolor{keyword}{false})
319         \{
320             std::cout << \textcolor{stringliteral}{"Error: Http context can't have any parameter.\(\backslash\)n"};
321             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
322         \}
323         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, possibleValidDirective.second));
324     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73}\label{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Location\+Context@{expect\+Location\+Context}}
\index{expect\+Location\+Context@{expect\+Location\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Location\+Context()}{expectLocationContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ expect\+Location\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 449 of file Parser.\+cpp.


\begin{DoxyCode}
450     \{
451         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
452         std::pair<bool, Directive> possibleValidDirective = \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{checkValidDirective}();
453 
454         \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{false}) 
455         \{
456             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
457             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
458         \}
459         \textcolor{keywordflow}{if} ((possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}) || 
460             (possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP}))
461         \{
462             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
463             std::cout << \textcolor{stringliteral}{"Error: There can't be any "} << \hyperlink{namespaceft_a2896a632198d516af93e4aea2d125f59}{sDirectiveKindStrings}[
      possibleValidDirective.second.directive] 
464                 << \textcolor{stringliteral}{" block inside a server block, currentToken is :"} << 
      \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
465             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
466         \}
467         \textcolor{keywordflow}{if} (possibleValidDirective.second.directive != \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION})
468         \{
469             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
470             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
471         \}
472         std::pair<bool, Token> possibleParameter = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER});
473         \textcolor{keywordflow}{if} (possibleParameter.first == \textcolor{keyword}{false})
474         \{
475             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
476             std::cout << \textcolor{stringliteral}{"Error: No parameter: Location directive should have one URI path\(\backslash\)n"};
477             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
478         \}
479         possibleValidDirective.second.parameters.push\_back(possibleParameter.second.text);
480         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, possibleValidDirective.second));
481     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd}\label{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Server\+Context@{expect\+Server\+Context}}
\index{expect\+Server\+Context@{expect\+Server\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Server\+Context()}{expectServerContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ expect\+Server\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 373 of file Parser.\+cpp.


\begin{DoxyCode}
374     \{
375         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
376         std::pair<bool, Directive> possibleValidDirective = \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{checkValidDirective}();
377 
378         \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{false}) 
379         \{
380             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
381             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
382         \}
383         \textcolor{keywordflow}{if} (possibleValidDirective.second.directive != \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER})
384         \{
385             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
386             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
387         \}
388         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, possibleValidDirective.second));
389     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a292bf0ed87b8e81b59cefb72c70152bd}\label{classft_1_1_parser_a292bf0ed87b8e81b59cefb72c70152bd}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Simple\+Directive@{expect\+Simple\+Directive}}
\index{expect\+Simple\+Directive@{expect\+Simple\+Directive}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Simple\+Directive()}{expectSimpleDirective()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ expect\+Simple\+Directive (\begin{DoxyParamCaption}\item[{enum \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75d}{Directive\+Kind}}]{kind }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 556 of file Parser.\+cpp.


\begin{DoxyCode}
557     \{
558         (void)\hyperlink{namespaceft_a1b9b00bc284da71346729142b8560e03}{ft::sTokenTypeStrings}[\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type]; \textcolor{comment}{// for debuging}
559         std::vector<Token>::iterator startToken = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
560         std::pair<bool, Directive> possibleValidDirective = \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{checkValidDirective}();
561 
562         \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{true})
563         \{
564             \textcolor{keywordflow}{if} ((possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP}) ||
565                     (possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}) ||
566                     (possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION})) \textcolor{comment}{// check block directive}
567             \{
568                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
569                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
570             \}
571             \textcolor{keywordflow}{if} (kind == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP} && 
572                 (possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da25b0e84438d71cc28e97f17a01cfde7a}{LIMIT\_EXCEPT} || 
573                 possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da331ec9878c0ed22e62de969d4b96b5bb}{LISTEN} || 
574                 possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8e7adb687472b53e3ed632cbcb949d88}{SERVER\_NAME} || 
575                 possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da520e09ffec033636dba711f3441cc600}{RETURN} || 
576                 possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da7b2e2f10add9bba874f82f39725423c5}{CGI} || 
577                 possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da874adc6c563690bc7a39ac6a0060e38a}{CGI\_PATH}))
578             \{
579                 std::cout << \textcolor{stringliteral}{"Error: There can't be "} << \hyperlink{namespaceft_a2896a632198d516af93e4aea2d125f59}{sDirectiveKindStrings}[
      possibleValidDirective.second.directive] << \textcolor{stringliteral}{" directive in http block.\(\backslash\)n"};
580                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
581                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
582             \}
583             \textcolor{keywordflow}{if} (kind == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER} && 
584                 (possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da25b0e84438d71cc28e97f17a01cfde7a}{LIMIT\_EXCEPT} || 
585                 possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da7b2e2f10add9bba874f82f39725423c5}{CGI} || 
586                 possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da874adc6c563690bc7a39ac6a0060e38a}{CGI\_PATH}))
587             \{
588                 std::cout << \textcolor{stringliteral}{"Error: There can't be "} << sDirectiveKindStrings[possibleValidDirective.
      second.directive] << \textcolor{stringliteral}{" directive in server block.\(\backslash\)n"};
589                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
590                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
591             \}
592             \textcolor{keywordflow}{if} (kind == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION} && 
593                 (possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da331ec9878c0ed22e62de969d4b96b5bb}{LISTEN} || 
594                 possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8e7adb687472b53e3ed632cbcb949d88}{SERVER\_NAME}))
595             \{
596                 std::cout << \textcolor{stringliteral}{"Error: There can't be "} << sDirectiveKindStrings[possibleValidDirective.
      second.directive] << \textcolor{stringliteral}{" directive in location block.\(\backslash\)n"};
597                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
598                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
599             \}
600         
601         \}
602         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{false})
603         \{
604             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} != \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} && \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{false})
605                 std::cout << \textcolor{stringliteral}{"Error: Unexpected directive, "} << \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{" in
       line, "} << \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->lineNumber << \textcolor{stringliteral}{"\(\backslash\)n"};
606             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
607             return (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
608         \}
609         \textcolor{keywordflow}{return} (\hyperlink{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98}{checkValidParameterNumber}(possibleValidDirective));
610     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a292bf0ed87b8e81b59cefb72c70152bd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a292bf0ed87b8e81b59cefb72c70152bd_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}\label{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Token@{expect\+Token}}
\index{expect\+Token@{expect\+Token}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Token()}{expectToken()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_token}{Token} $>$ expect\+Token (\begin{DoxyParamCaption}\item[{enum \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921}{Token\+Type}}]{type,  }\item[{const std\+::string \&}]{name = {\ttfamily std\+:\+:string()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 99 of file Parser.\+cpp.


\begin{DoxyCode}
100     \{
101         Token returnToken;
102 
103         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} == \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_})
104             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, returnToken));
105         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type != type)
106             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, returnToken));
107         \textcolor{keywordflow}{if} (!name.empty() && \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text != name)
108             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, returnToken));
109 
110         returnToken = *\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
111         ++\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
112         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, returnToken));
113     \}
\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08}\label{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!modify\+Identifier\+Token@{modify\+Identifier\+Token}}
\index{modify\+Identifier\+Token@{modify\+Identifier\+Token}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{modify\+Identifier\+Token()}{modifyIdentifierToken()}}
{\footnotesize\ttfamily void modify\+Identifier\+Token (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$ \&}]{tokens }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 56 of file Parser.\+cpp.


\begin{DoxyCode}
57     \{
58         \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = tokens.begin();
59         \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} = tokens.end();
60 
61         \textcolor{keywordflow}{for} (;\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} != \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_}; ++\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_})
62         \{
63             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type == \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a84f8ae2490f9e4bd2321fd21f4b0e807}{IDENTIFIER})
64             \{
65                 \textcolor{keywordtype}{int} i = 0, foundDirectiveKind = -1;
66                 \textcolor{keywordflow}{while} (i < \hyperlink{_directive_8hpp_a0ad99aeee867cb461c93463d5772ac86}{LAST\_DIRECTIVE\_KIND} + 1)
67                 \{
68                     foundDirectiveKind = \hyperlink{namespaceft_a2896a632198d516af93e4aea2d125f59}{sDirectiveKindStrings}[i].compare(
      \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text);
69                     \textcolor{keywordflow}{if} (foundDirectiveKind == 0)
70                     \{
71                         \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type = \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921ae3852cb010d5e422026faf83b3c16f0e}{DIRECTIVE};
72                         break ;
73                     \}
74                     i++;
75                 \}
76                 \textcolor{keywordflow}{if} (i == \hyperlink{_directive_8hpp_a0ad99aeee867cb461c93463d5772ac86}{LAST\_DIRECTIVE\_KIND} + 1)
77                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type = \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER};
78             \}
79 
80         \}
81     \}
\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248}\label{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse@{parse}}
\index{parse@{parse}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse()}{parse()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_http_block}{Http\+Block} $>$ parse (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$ \&}]{tokens }\end{DoxyParamCaption})}



Definition at line 24 of file Parser.\+cpp.


\begin{DoxyCode}
25     \{
26         \hyperlink{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08}{modifyIdentifierToken}(tokens);
27         \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = tokens.begin();
28         \hyperlink{classft_1_1_parser_a85bbb595991c68a1ec2751fabcb8eae5}{startToken\_} = tokens.begin();
29         \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} = tokens.end();
30         std::pair<bool, HttpBlock> possibleHttpContext;
31         std::pair<bool, Directive> possibleValidDirective;
32 
33         \textcolor{keywordflow}{while} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} != \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_})
34         \{
35             possibleValidDirective = \hyperlink{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b}{expectHttpContext}();
36             \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{false})
37             \{
38                 \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\{"}).first == \textcolor{keyword}{false})
39                 \{
40                     \textcolor{comment}{//std::cout << "Error: Http context can't have any parameter.\(\backslash\)n";}
41                     \textcolor{keywordflow}{return} (possibleHttpContext);
42                 \}
43                 \textcolor{keywordflow}{else}
44                     ++\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
45             \}
46             \textcolor{keywordflow}{else}
47             \{
48                 possibleHttpContext = \hyperlink{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d}{parseHttpContext}(possibleValidDirective);
49                 \textcolor{keywordflow}{if} (possibleHttpContext.first == \textcolor{keyword}{false})
50                     \textcolor{keywordflow}{return} (possibleHttpContext);
51             \}
52         \}
53         \textcolor{keywordflow}{return} (possibleHttpContext);
54     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a2d0fd9222eca5d8ea7e8fbb79f0a30be}\label{classft_1_1_parser_a2d0fd9222eca5d8ea7e8fbb79f0a30be}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse\+Context\+Body@{parse\+Context\+Body}}
\index{parse\+Context\+Body@{parse\+Context\+Body}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse\+Context\+Body()}{parseContextBody()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ $>$ parse\+Context\+Body (\begin{DoxyParamCaption}\item[{enum \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75d}{Directive\+Kind}}]{kind }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 512 of file Parser.\+cpp.


\begin{DoxyCode}
513     \{
514         std::vector<Directive>  directives;
515         std::pair<bool, Directive> simpleDirective = \hyperlink{classft_1_1_parser_a292bf0ed87b8e81b59cefb72c70152bd}{expectSimpleDirective}(kind);
516 
517         \textcolor{keywordflow}{while} (simpleDirective.first == \textcolor{keyword}{true})
518         \{
519             directives.push\_back(simpleDirective.second);
520             simpleDirective = \hyperlink{classft_1_1_parser_a292bf0ed87b8e81b59cefb72c70152bd}{expectSimpleDirective}(kind);
521         \}
522         \textcolor{keywordflow}{if} (simpleDirective.first == \textcolor{keyword}{false}) \textcolor{comment}{// check if it is a context or an error}
523         \{
524             \textcolor{comment}{//std::cout << "simpleDirective first false, kind: " << kind << "\(\backslash\)n";}
525             \textcolor{keywordflow}{if} (kind == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP} && (simpleDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}))
526             \{
527                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, directives));
528             \}
529             \textcolor{keywordflow}{if} (kind == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER} && (simpleDirective.second.directive == 
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION}))
530                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, directives));
531             \textcolor{keywordflow}{if} (kind == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP} && (simpleDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP} || simpleDirective.second
      .directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION}))
532             \{
533                 std::cout << \textcolor{stringliteral}{"Error: There can't be any other block than server in http block.\(\backslash\)n"};
534                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, directives));
535             \}
536             
537             \textcolor{keywordflow}{if} (kind == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER} && ((simpleDirective.second.directive == 
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}) || (simpleDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP})))
538             \{
539                 std::cout << \textcolor{stringliteral}{"Error: There can't be any other block than location in server block.\(\backslash\)n"};
540                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, directives));
541             \}
542             \textcolor{keywordflow}{if} (kind == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION} && ((simpleDirective.second.directive == 
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}) || (simpleDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP}) || (simpleDirective.second.directive == 
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION})))
543             \{
544                 std::cout << \textcolor{stringliteral}{"Error: There can't be any other block in location block.\(\backslash\)n"};
545                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, directives));
546             \}
547             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{true})
548             \{
549                 --\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
550                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, directives));
551             \}
552         \}
553         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, directives));
554     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a2d0fd9222eca5d8ea7e8fbb79f0a30be_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a2d0fd9222eca5d8ea7e8fbb79f0a30be_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d}\label{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse\+Http\+Context@{parse\+Http\+Context}}
\index{parse\+Http\+Context@{parse\+Http\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse\+Http\+Context()}{parseHttpContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_http_block}{Http\+Block} $>$ parse\+Http\+Context (\begin{DoxyParamCaption}\item[{std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$}]{valid\+Directive }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 326 of file Parser.\+cpp.


\begin{DoxyCode}
327     \{
328         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
329         std::pair<bool, std::vector<Directive> > directives;
330         HttpBlock   httpContext;
331 
332         \textcolor{keywordflow}{while} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} != \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} - 1 && 
      \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{false})
333         \{
334             validDirective = \hyperlink{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd}{expectServerContext}();
335             \textcolor{keywordflow}{if} (validDirective.first == \textcolor{keyword}{false})
336             \{
337                 directives = \hyperlink{classft_1_1_parser_a2d0fd9222eca5d8ea7e8fbb79f0a30be}{parseContextBody}(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP});
338                 \textcolor{keywordflow}{if} (directives.first == \textcolor{keyword}{false})
339                 \{
340                     \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} == \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} && 
      \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{false})
341                     \{
342                         std::cout << \textcolor{stringliteral}{"Error: Http context has not successfuly been enclosed with a closing
       curly bracket.\(\backslash\)n"};
343                         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
344                     \}
345                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
346                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
347                 \}
348                 \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf}{setHttpDirectiveParameter}(httpContext, directives.second) == \textcolor{keyword}{
      false})
349                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
350                 
351             \}
352             \textcolor{keywordflow}{else}
353             \{
354                 \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\{"}).first == \textcolor{keyword}{false})
355                 \{
356                     std::cout << \textcolor{stringliteral}{"Error: Server block should start with a curly bracket.\(\backslash\)n"};
357                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
358                 \}
359                 std::pair<bool, ServerBlock>    possibleServerContext = 
      \hyperlink{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230}{parseServerContext}(httpContext, validDirective);
360 
361                 \textcolor{keywordflow}{if} (possibleServerContext.first == \textcolor{keyword}{false})
362                 \{
363                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
364                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
365                 \}
366                 httpContext.serverList.push\_back(possibleServerContext.second);
367             \}
368 
369         \}
370         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, httpContext));
371     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a87f0f31d2bc2e6357d522e70256878ca}\label{classft_1_1_parser_a87f0f31d2bc2e6357d522e70256878ca}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse\+Location\+Context@{parse\+Location\+Context}}
\index{parse\+Location\+Context@{parse\+Location\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse\+Location\+Context()}{parseLocationContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_location_block}{Location\+Block} $>$ parse\+Location\+Context (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_server_block}{Server\+Block} \&}]{server\+Context }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 483 of file Parser.\+cpp.


\begin{DoxyCode}
484     \{
485         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
486         std::pair<bool, std::vector<Directive> > directives;
487         std::pair<bool, Token> possibleOperator;
488         LocationBlock   locationContext(serverContext);
489 
490         possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"});
491         \textcolor{keywordflow}{while} (possibleOperator.first == \textcolor{keyword}{false})
492         \{
493             directives = \hyperlink{classft_1_1_parser_a2d0fd9222eca5d8ea7e8fbb79f0a30be}{parseContextBody}(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION});
494             \textcolor{keywordflow}{if} (directives.first == \textcolor{keyword}{false})
495             \{
496                 \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} == \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} && 
      \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{false})
497                 \textcolor{comment}{//if (currentToken\_->text != "location" && expectToken(OPERATOR, "\}").first == false)}
498                 \{
499                     std::cout << \textcolor{stringliteral}{"Error: Location context has not successfuly been enclosed with a closing
       curly bracket.\(\backslash\)n"};
500                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, locationContext));
501                 \}
502                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
503                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, locationContext));
504             \}
505             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c}{setLocationDirectiveParameter}(locationContext, directives.
      second) == \textcolor{keyword}{false})
506                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, locationContext));
507             possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"});
508         \}
509         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, locationContext));
510     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a87f0f31d2bc2e6357d522e70256878ca_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a87f0f31d2bc2e6357d522e70256878ca_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230}\label{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse\+Server\+Context@{parse\+Server\+Context}}
\index{parse\+Server\+Context@{parse\+Server\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse\+Server\+Context()}{parseServerContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_server_block}{Server\+Block} $>$ parse\+Server\+Context (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_http_block}{Http\+Block} \&}]{http\+Context,  }\item[{std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$}]{valid\+Directive }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 391 of file Parser.\+cpp.


\begin{DoxyCode}
392     \{
393         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
394         std::pair<bool, std::vector<Directive> > directives;
395         std::pair<bool, Token> possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"});
396 
397         ServerBlock serverContext(httpContext);
398         \textcolor{keywordflow}{while} (possibleOperator.first == \textcolor{keyword}{false})
399         \{
400             validDirective = \hyperlink{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73}{expectLocationContext}();
401             \textcolor{keywordflow}{if} (validDirective.first == \textcolor{keyword}{false} &&
402                  (validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER} || validDirective.second.directive == 
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP} || validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION}))
403             \{
404                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
405                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
406             \}
407             \textcolor{comment}{//else if ((validDirective.first == false) &&}
408                      \textcolor{comment}{//(validDirective.second.directive != LOCATION))}
409             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (validDirective.first == \textcolor{keyword}{false})
410             \{
411                 directives = \hyperlink{classft_1_1_parser_a2d0fd9222eca5d8ea7e8fbb79f0a30be}{parseContextBody}(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER});
412                 \textcolor{keywordflow}{if} (directives.first == \textcolor{keyword}{false})
413                 \{
414                     \textcolor{comment}{//if (expectToken(DIRECTIVE).first == false)}
415                     \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} == \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} && 
      \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{false})
416                     \{
417                         std::cout << \textcolor{stringliteral}{"Error: Server context has not successfuly been enclosed with a
       closing curly bracket.\(\backslash\)n"};
418                         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
419                     \}
420                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
421                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
422                 \}
423                 \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f}{setServerDirectiveParameter}(serverContext, directives.second
      ) == \textcolor{keyword}{false})
424                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
425             \}
426             \textcolor{keywordflow}{else}
427             \{
428                 \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\{"}).first == \textcolor{keyword}{false})
429                 \{
430                     std::cout << \textcolor{stringliteral}{"Error: Multiple parameters, location directive should only have one URI
       path\(\backslash\)n"};
431                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
432                 \}
433                 std::pair<bool, LocationBlock>  possibleLocationContext = 
      \hyperlink{classft_1_1_parser_a87f0f31d2bc2e6357d522e70256878ca}{parseLocationContext}(serverContext);
434                         
435                 \textcolor{keywordflow}{if} (possibleLocationContext.first == \textcolor{keyword}{false})
436                 \{
437                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
438                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
439                 \}
440                 serverContext.locationList.push\_back(possibleLocationContext.second);
441             \}
442             possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"});
443         \}
444 
445         \textcolor{comment}{//if (currentToken\_ == endToken\_ - 1 && expectToken(OPERATOR, "\}").first == false)}
446         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, serverContext));
447     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}\label{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!set\+Base\+Directive\+Parameter@{set\+Base\+Directive\+Parameter}}
\index{set\+Base\+Directive\+Parameter@{set\+Base\+Directive\+Parameter}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{set\+Base\+Directive\+Parameter()}{setBaseDirectiveParameter()}}
{\footnotesize\ttfamily bool set\+Base\+Directive\+Parameter (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_base_directives}{Base\+Directives} \&}]{context,  }\item[{std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$\+::iterator \&}]{current\+Directive }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 208 of file Parser.\+cpp.


\begin{DoxyCode}
209     \{
210         \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da026a7fa9f276b046081164564a62a6d6}{CLIENT\_MAX\_BODY\_SIZE})
211         \{
212             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}       value;
213             std::string     inputString = (*currentDirective->parameters.begin());
214             std::string::size\_type  n;
215 
216             \textcolor{keywordflow}{if} (inputString.length() != 0)
217             \{
218                 n = inputString.find\_first\_not\_of(\textcolor{stringliteral}{"0123456789"});
219                 \textcolor{keywordflow}{if} (n == std::string::npos)
220                 \{   
221                     value = std::strtoul((*currentDirective->parameters.begin()).c\_str(), NULL, 10); \textcolor{comment}{//
       string to unsigned long}
222                     context.setClientMaxBodySize(value); 
223                 \}
224                 \textcolor{keywordflow}{else}
225                 \{
226                     std::cout << \textcolor{stringliteral}{"Error: client\_max\_body\_size parameter should be an integer literal.\(\backslash\)n"};
227                     \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
228                 \}
229 
230             \}
231         \}
232         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75daaefe179bd74ff161beb62eb565186d89}{KEEPALIVE\_TIMEOUT})
233         \{
234             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}        value;
235             std::string     inputString = (*currentDirective->parameters.begin());
236             std::string::size\_type  n;
237 
238             \textcolor{keywordflow}{if} (inputString.length() != 0)
239             \{
240                 n = inputString.find\_first\_not\_of(\textcolor{stringliteral}{"0123456789"});
241                 \textcolor{keywordflow}{if} (n == std::string::npos)
242                 \{   
243                     std::istringstream(*currentDirective->parameters.begin()) >> value; \textcolor{comment}{// string to
       unsigned int}
244                     context.setKeepaliveTimeout(value); 
245                 \}
246                 \textcolor{keywordflow}{else}
247                 \{
248                     std::cout << \textcolor{stringliteral}{"Error: keepalive\_timeout parameter should be an integer literal.\(\backslash\)n"};
249                     \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
250                 \}
251 
252             \}
253 
254         \}
255         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8ce880864e00bec4865ba027e32a466c}{AUTOINDEX})
256         \{
257             \textcolor{keywordflow}{if} ((*currentDirective->parameters.begin()) == \textcolor{stringliteral}{"on"})
258                 context.setAutoindex(\textcolor{keyword}{true});
259             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((*currentDirective->parameters.begin()) == \textcolor{stringliteral}{"off"})
260                 context.setAutoindex(\textcolor{keyword}{false});
261             \textcolor{keywordflow}{else}
262             \{
263                 std::cout << \textcolor{stringliteral}{"Error: autoindex parameter should be either 'on' or 'off'.\(\backslash\)n"};
264                 \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
265             \}
266         \}
267         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75dad41208b99e347d1726824779b11ea11b}{ROOT})
268             context.setRoot((*currentDirective->parameters.begin()));
269         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da69c9592b502329f43c77ad043a13e6d9}{ERROR\_PAGE})
270             context.setErrorPage(*(currentDirective->parameters.begin()));
271         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da5f0c05bad71a7b0dd266aae7ce4b3579}{INDEX})
272         \{
273             std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin();
274             std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
275 
276             context.clearIndex();
277             \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
278                 context.setIndex(*currentParameter);
279         \}
280         \textcolor{keywordflow}{return} (\textcolor{keyword}{true});
281     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf}\label{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!set\+Http\+Directive\+Parameter@{set\+Http\+Directive\+Parameter}}
\index{set\+Http\+Directive\+Parameter@{set\+Http\+Directive\+Parameter}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{set\+Http\+Directive\+Parameter()}{setHttpDirectiveParameter()}}
{\footnotesize\ttfamily bool set\+Http\+Directive\+Parameter (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_http_block}{Http\+Block} \&}]{context,  }\item[{std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$}]{directive\+List }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 283 of file Parser.\+cpp.


\begin{DoxyCode}
284     \{
285         std::vector<Directive>::iterator    currentDirective = directiveList.begin();
286         std::vector<Directive>::iterator    endDirective = directiveList.end();
287 
288         \textcolor{keywordflow}{for} (; currentDirective != endDirective; ++currentDirective)
289             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}{setBaseDirectiveParameter}(context, currentDirective) == \textcolor{keyword}{false})
290                 \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
291         \textcolor{keywordflow}{return} (\textcolor{keyword}{true});
292     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c}\label{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!set\+Location\+Directive\+Parameter@{set\+Location\+Directive\+Parameter}}
\index{set\+Location\+Directive\+Parameter@{set\+Location\+Directive\+Parameter}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{set\+Location\+Directive\+Parameter()}{setLocationDirectiveParameter()}}
{\footnotesize\ttfamily bool set\+Location\+Directive\+Parameter (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_location_block}{Location\+Block} \&}]{context,  }\item[{std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$}]{directive\+List }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 169 of file Parser.\+cpp.


\begin{DoxyCode}
170     \{
171         std::vector<Directive>::iterator    currentDirective = directiveList.begin();
172         std::vector<Directive>::iterator    endDirective = directiveList.end();
173 
174         \textcolor{keywordflow}{for} (; currentDirective != endDirective; ++currentDirective)
175         \{
176             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}{setBaseDirectiveParameter}(context, currentDirective) == \textcolor{keyword}{false})
177                 \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
178             \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da520e09ffec033636dba711f3441cc600}{RETURN})
179             \{
180                 std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin()
      ;
181                 std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
182                 \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
183                     context.setReturn(*currentParameter);
184                 \textcolor{comment}{// return error code error handling}
185             \}
186             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da25b0e84438d71cc28e97f17a01cfde7a}{LIMIT\_EXCEPT})
187             \{
188                 std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin()
      ;
189                 std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
190                 \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
191                     context.setLimitExcept(*currentParameter);
192             \}
193             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da7b2e2f10add9bba874f82f39725423c5}{CGI})
194             \{
195                 std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin()
      ;
196                 std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
197                 \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
198                     context.setCgi(*currentParameter);
199             \}
200             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da874adc6c563690bc7a39ac6a0060e38a}{CGI\_PATH})
201             \{
202                 context.setCgiPath((*currentDirective->parameters.begin()));
203             \}
204         \}
205         \textcolor{keywordflow}{return} (\textcolor{keyword}{true});
206     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f}\label{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!set\+Server\+Directive\+Parameter@{set\+Server\+Directive\+Parameter}}
\index{set\+Server\+Directive\+Parameter@{set\+Server\+Directive\+Parameter}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{set\+Server\+Directive\+Parameter()}{setServerDirectiveParameter()}}
{\footnotesize\ttfamily bool set\+Server\+Directive\+Parameter (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_server_block}{Server\+Block} \&}]{context,  }\item[{std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$}]{directive\+List }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 115 of file Parser.\+cpp.


\begin{DoxyCode}
116     \{
117         std::vector<Directive>::iterator    currentDirective = directiveList.begin();
118         std::vector<Directive>::iterator    endDirective = directiveList.end();
119 
120         \textcolor{keywordflow}{for} (; currentDirective != endDirective; ++currentDirective)
121         \{
122             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}{setBaseDirectiveParameter}(context, currentDirective) == \textcolor{keyword}{false})
123                 \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
124             \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da331ec9878c0ed22e62de969d4b96b5bb}{LISTEN})
125             \{
126                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}        value;
127                 std::string     inputString = (*currentDirective->parameters.begin());
128                 std::string::size\_type  n;
129 
130                 \textcolor{keywordflow}{if} (inputString.length() != 0)
131                 \{
132                     n = inputString.find\_first\_not\_of(\textcolor{stringliteral}{"0123456789"});
133                     \textcolor{keywordflow}{if} (n == std::string::npos)
134                     \{   
135                         std::istringstream(*currentDirective->parameters.begin()) >> value; \textcolor{comment}{// string to
       unsigned int}
136                         context.setListen(value);
137                     \}
138                     \textcolor{keywordflow}{else}
139                     \{
140                         std::cout << \textcolor{stringliteral}{"Error: listen parameter should be an integer literal.\(\backslash\)n"};
141                         \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
142                     \}
143 
144                 \}
145             \}
146             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8e7adb687472b53e3ed632cbcb949d88}{SERVER\_NAME})
147             \{
148                 std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin()
      ;
149                 std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
150 
151                 context.clearServerName();
152                 \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
153                 \{
154                     context.setServerName(*currentParameter);
155                 \}
156             \}
157             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da520e09ffec033636dba711f3441cc600}{RETURN})
158             \{
159                 std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin()
      ;
160                 std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
161                 \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
162                     context.setReturn(*currentParameter);
163                 \textcolor{comment}{// return error code error handling}
164             \}
165         \}
166         \textcolor{keywordflow}{return} (\textcolor{keyword}{true});
167     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f_icgraph}
\end{center}
\end{figure}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}\label{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!current\+Token\+\_\+@{current\+Token\+\_\+}}
\index{current\+Token\+\_\+@{current\+Token\+\_\+}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{current\+Token\+\_\+}{currentToken\_}}
{\footnotesize\ttfamily std\+::vector$<$\hyperlink{classft_1_1_token}{Token}$>$\+::iterator current\+Token\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 17 of file Parser.\+hpp.

\mbox{\Hypertarget{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}\label{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!directives\+\_\+@{directives\+\_\+}}
\index{directives\+\_\+@{directives\+\_\+}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{directives\+\_\+}{directives\_}}
{\footnotesize\ttfamily std\+::map$<$std\+::string, \hyperlink{classft_1_1_directive}{Directive}$>$ directives\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 20 of file Parser.\+hpp.

\mbox{\Hypertarget{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}\label{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!end\+Token\+\_\+@{end\+Token\+\_\+}}
\index{end\+Token\+\_\+@{end\+Token\+\_\+}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{end\+Token\+\_\+}{endToken\_}}
{\footnotesize\ttfamily std\+::vector$<$\hyperlink{classft_1_1_token}{Token}$>$\+::iterator end\+Token\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 19 of file Parser.\+hpp.

\mbox{\Hypertarget{classft_1_1_parser_a85bbb595991c68a1ec2751fabcb8eae5}\label{classft_1_1_parser_a85bbb595991c68a1ec2751fabcb8eae5}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!start\+Token\+\_\+@{start\+Token\+\_\+}}
\index{start\+Token\+\_\+@{start\+Token\+\_\+}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{start\+Token\+\_\+}{startToken\_}}
{\footnotesize\ttfamily std\+::vector$<$\hyperlink{classft_1_1_token}{Token}$>$\+::iterator start\+Token\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 18 of file Parser.\+hpp.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/cjung-\/mo/\+Documents/42/\+Webserv/config/src/\hyperlink{_parser_8hpp}{Parser.\+hpp}\item 
/home/cjung-\/mo/\+Documents/42/\+Webserv/config/src/\hyperlink{_parser_8cpp}{Parser.\+cpp}\end{DoxyCompactItemize}

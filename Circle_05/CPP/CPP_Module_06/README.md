# < CAST > CPP module 06

> 이 모듈에서는, 캐스팅과, 참조값, 포인터에 대한 공부를 다시한번 하게된다.

#### 묵시적, 명시적 캐스팅
캐스팅에는 묵시적 캐스팅 그리고 명시적 캐스팅이있다.
묵시적캐스팅은 int 값이 자동으로 char로 캐스팅되는 부분을 예로 들수있다.
```cpp
int i = 48; ==> print("%c\n", i);
```
명시적 캐스팅은 말그대로 명시적으로 캐스팅을 해주는 경우이다.
```cpp
int	i = 48;
(char)i;
```
이것을 설명하는이유는 c++에서 명시적캐스팅을 뜻하는건, static_cast이기 때문이다.
하지만, static_cast는 "명시적" 이며, 동시에 "안전"하다. 

#### 참조값
> 참조값은 새롭게 변수에 할당된값을 복사해서 쓰지않고, 그대로 접근해서 쓸수있기때문에, 메모리에 자원을 절약할수있다는 점에서 아주 좋은 방법이다.

```cpp
// 함수의 파라미터로서의 참조값
void	ft_exemple(int i, int j); // int i, int j는 함수가 불리면 새롭게 메모리 공간을 차지함

void	ft_exemple(int &i, int &j); // int i, int j는 함수가 불리면 새롭게  메모리 공간을 차지하지않음

// 함수의 반환값으로서의 참조값  -> 댕글링 참조자
int	&ft_exemple(void)
{
	...
	return (ret);
}

// 반환값으로서의 참조자, 그러나 받는 변수에따라 ..
int	&ref = ft_exemple(i);
int	ref_2 = ft_exemple(i);

ref2는 그냥 값을 받은것뿐, ref는 참조자로서 값을 받음

// const , non-const
const int &ex = 42;		// 가능, 임시 변수생성후에 할당
int &ex = 42;			// 안됨, 변수로 만든후에 넣어줘야함.

// 참조자는 변수를 만든후에, 그 변수값을 r_value에 넣어줘야함. r_value는 원래가 메모리에 잠깐있다가 사라지는 개념이라, l_value의 값이 필요함. 그래야지 참조자의 역활처럼 메모리를 다른이름으로 공유함.
```

## ex00 : static_cast
> 명시적이며, 안전한 캐스팅. 컴파일시에 오류및 실행가능여부를 판단한다.


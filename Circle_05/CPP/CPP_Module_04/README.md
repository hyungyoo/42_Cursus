# 다형성

## 오버로딩
> 오버로딩은 함수의 재정의 이다. 그렇다면, 다형성과 오버로딩의 관계는?
다형성은, 객체지향에서 뜻하는 바가 많지만, 상속관계에서 많이쓰인다.
부모가 정의해놓은 함수를 자식이 다시 재정의하는것이다. 일반적인 상속관계에서 오버로딩은 덮어쓰기가 된다.
하지만, 부모의 클래스포인터로 자식의 클래스에 접근한다면? 그렇다면, c++ 컴파일러는 오버로딩하기전의 부모함수에 접근한다.

```cpp

class A
{
	public:
		void	func(void)
		{
			std::cout << "A" << std::endl;
		}
};

class B : public A
{
	public:
		void 	func(void)
		{
			std::cout << "B" << std::endl;
		}
};

int	main(void)
{
	A	*ptr = new B();
	ptr->func();
	return (0);
}
```
위의 예를 보면, 결과값은 A이다. 왜? 오버로딩을 하였지만, 컴파일러는 런타임중에 부모의 포인터인것을 보고 부모의 멤버함수에접근한다.
그렇다면, 어떻게 해야지 부모의 포인터로 자식의 멤버함수에 접근할수있을까?

## virtual
> 위의 문제를 해결하기위한 방법은 "virutal" 을 쓰는것이다. virtual로 멤버함수를 선언한다면, vtable에 자식의 주소값이 생기고, 런타임중 자식의 멤버함수에 접근한다.

```cpp

class A
{
	public:
		virtual void	func(void)
		{
			std::cout << "A" << std::endl;
		}
};

class B : public A
{
	public:
		virtual void 	func(void)
		{
			std::cout << "B" << std::endl;
		}
};

int	main(void)
{
	A	*ptr = new B();
	ptr->func();
	return (0);
}
```

이렇게 부모의 클래스포인터로 자식의 클래스에 접근하는방식을 "업 캐스팅" 이라고한다.

## 왜 이렇게 할까?
> 다형성의 특징때문이다. 벡터나 여러가지를 이용하여, 부모의 클래스포인터로 모든 상속되는 자식 클래스에 접근가능하다.
자동차라는 부모클래스에, 각 자동차모델들로 구성된 자식클래스가있다면, 새로나온 법에의해, 유리를 방탄유리로바꿔야한다면?
다형성이라는 특징으로, 업캐스팅을 이용하여, 효율적인 처리가 가능하다!

## virtual을 소멸자에 붙이는이유는?
> virtual을 소멸자에 붙이는 이유는, 앞서 언급에서 처럼, 컴파일러는 부모클래스의 포인터로만 판단을하기때문에, virtual이 붙어있지않다면, 소멸자는 부모의 소멸자만을 부른뒤 사라진다.그렇게된다면, 자식클래스에 할당된 메모리에서 누수가 발생하기때문에, 소멸자에도 virtual을 써준다.
